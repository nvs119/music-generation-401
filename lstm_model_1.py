# -*- coding: utf-8 -*-
"""niva copy of Tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MAXn-vo_rVzkgW5dF0PjcH1IRhrYINh6

##### Copyright 2019 The TensorFlow Authors.
"""

#@title Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount("/content/gdrive")
# %cd gdrive/Shareddrives/COS\ 401
# %cd dataset

import csv
import numpy
import os
import pandas as pd

import math
note_order = {'C0': 0, 'C#' : 1, 'Db': 1, 'C2': 2, 'D0': 2, 'D#': 3,
              'Eb': 3, 'E0': 4, 'E#': 5, 'Fb': 4, 'F0': 5, 'F#': 6,
              'Gb': 6, 'G0': 7, 'G#': 8, 'Ab': 8, 'A0': 9,
              'A#': 10, 'Bb': 10, 'B0': 11, 'B#': 0, 'Cb': 11, "rest": math.inf,
              'F2': 7, 'C2': 2, 'D2': 4, 'G2': 9, 'A2': 11, 'B-2': 9, 'B2': 1,
              'E2': 6, 'A-2': 7, 'C-2': 10, 'D-2': 0, 'E-2': 2, 'F-2': 3, "[]": -1}

def get_note_from_name(note_name):
  return note_order[note_name]


def get_standardized_note(note_name, key_fifths):
  if note_name == "rest":
    return -1
  note = get_note_from_name(note_name)
  return (note - 7*int(key_fifths) % 12) % 12

# standardize notes and chords in all train files

standardized_pds = []
for song in os.listdir("csv_train"):
  file_pd = pd.read_csv("csv_train/" + str(song))
  new_notes = []
  # print(song)

  for i in range(len(file_pd["note_root"])):
    new_notes.append(get_standardized_note(file_pd["note_root"][i], file_pd["key_fifths"][i]))

  file_pd["standardized_note"] = new_notes

  new_chords = []

  for i in range(len(file_pd["chord_root"])):
    new_chords.append(get_standardized_note(file_pd["chord_root"][i], file_pd["key_fifths"][i]))

  file_pd["standardized_chord"] = new_chords

  standardized_pds.append(file_pd)

# (note, chord, chord_type, octave)

chord_types_to_nums = {'major': 0, 'minor': 1, 'dominant':2,
          'major-seventh': 3, 'minor-seventh': 4,
          'major-sixth': 5, 'minor-sixth': 6, 
          'major-ninth': 7, 'minor-ninth': 8,
          'power': 9, 'half-diminished': 10, 
          'suspended-fourth': 11, 'dominant-13th': 12,
          'dominant-ninth': 13, 'nan': 14, '[]': 14, 'augmented':15,
          'augmented-seventh':16, 'maj': 0, 'min':1, 'maj7':3, '7':2,
          'diminished':17, 'dominant-seventh':2, 'diminished-seventh':18,
          'major-minor':19, 'maj69':20, 'dominant-11th':21, 'augmented-ninth':22,
          'min7':4, 'dim': 17, float("NaN"): 14, 'minor-major': 23}

nums_to_chord_types = {v:k for k, v in chord_types_to_nums.items()}

import string
note_dataset = []
import random

hello = []

for file_pd in standardized_pds:
  # note_dataset.append("13 major 13 13")
  notes_in_song = list(zip(file_pd["standardized_chord"], file_pd["chord_type"], file_pd["standardized_note"], file_pd["note_octave"]))
  # hello.append(set(file_pd["standardized_note"]))
  for note in notes_in_song:
    assert len(note) == 4
    new_note = []
    for i in note:
      if type(i) == str:
        new_note.append(i.strip())
      else:
        new_note.append(i)
    note = new_note
    final_note = []
    final_note.append(note[0])
    try:
      final_note.append(chord_types_to_nums[note[1]])
    except:
      if type(note[1]) == float:
        final_note.append(chord_types_to_nums['nan'])
      else:
        final_note.append(chord_types_to_nums['maj'])
    final_note.append(note[2])
    final_note.append(note[3])
    note_dataset.append(final_note)

# print(hello[0].union(hello[1:]))

# import string

print(note_dataset[2])

import tensorflow as tf

import numpy as np
import os
import time

def split_input_target(sequence):
    input_text = sequence[:-1]
    target_text = sequence[-1]
    return input_text, target_text

all_ids = tf.convert_to_tensor(note_dataset)

all_ids

ids_dataset = tf.data.Dataset.from_tensor_slices(all_ids)

for ids in ids_dataset.take(20):
    print(ids.numpy())

seq_length = 100
examples_per_epoch = len(note_dataset)//(seq_length+1)

examples_per_epoch

sequences = ids_dataset.batch(seq_length+1, drop_remainder=True)

for seq in sequences.take(1):
  print(seq)

dataset = sequences.map(split_input_target)

for input_example, target_example in dataset.take(1):
    print("Input :", input_example.numpy())
    print("Target:", target_example.numpy())

# Batch size
BATCH_SIZE = 64

# Buffer size to shuffle the dataset
# (TF data is designed to work with possibly infinite sequences,
# so it doesn't attempt to shuffle the entire sequence in memory. Instead,
# it maintains a buffer in which it shuffles elements).
BUFFER_SIZE = 10000

dataset = (
    dataset
    .shuffle(BUFFER_SIZE)
    .batch(BATCH_SIZE, drop_remainder=True)
    .prefetch(tf.data.experimental.AUTOTUNE))

dataset

from keras.models import Sequential
from keras.layers import Dense, LSTM


model1 = Sequential()
model1.add(LSTM(256, input_shape=(None,4)))
model1.add(tf.keras.layers.Flatten())
# model1.add(Dense(128))
model1.add(Dense(4))
model1.compile(loss=tf.keras.losses.MeanSquaredError(), optimizer='sgd')
model1.summary()

print(model1.input)


# model2 = model1(inputs=model_input, outputs=model_output)

model1.fit(dataset, epochs = 20)

y = np.concatenate([y for x, y in dataset], axis=0)
# print(y)

ynew = model1.predict(dataset)
ynew

ynew = model1.predict(dataset)
rounded = np.around(ynew)
rounded

print(nums_to_chord_types)
print(nums_to_chord_types.get(1))

for note_tf in rounded:
  print(note_tf)

chords = []
chord_types = []
notes = []
octaves = []
measures = []
duration = []
count = 0
measure = 0
for note_tf in rounded:
  # note_str = note_tf[0].numpy().decode('utf-8')
  # splitup = note_str.split(" ")
  # if splitup[0] in ["", " "]:
  #   splitup.pop(0)
  chords.append(int(note_tf[0]))

  chord_types.append(nums_to_chord_types.get(note_tf[1]))
  notes.append(int(note_tf[2]))
  octaves.append(int(note_tf[3]))
  duration.append(4)
  if count % 4 == 0:
    measure += 1
  count += 1
  measures.append(measure)



predict_pd = pd.DataFrame(list(zip(chords, chord_types, notes, octaves, duration, measures)),
                      columns = ["standardized_chord", "chord_type", "standardized_note", "note_octave", 
                      "note_duration", "measure"])

predict_pd.head()

predict_pd

from google.colab import files

!pip install magenta
import magenta
import note_seq
import tensorflow

from note_seq.protobuf import music_pb2

CHORDS_KEY = {'major': [4, 7], 'maj': [4, 7], 'min': [3, 7], 'minor':[3, 7], 'dominant':[4, 7, 10],
              'maj7': [4, 7, 11], 'min7': [3, 7, 9], 'dominant-seventh': [4, 7, 10],
          'major-seventh': [4, 7, 11], 'minor-seventh': [3, 7, 9],
          'major-sixth':[4, 7, 9], 'minor-sixth':[3, 7, 9], 
          'major-ninth':[4, 7, 10, 14], 'minor-ninth': [3, 7, 9, 14],
          'power': [5], 'half-diminished': [3, 5], 
          'suspended-fourth': [5, 7], 'dominant-13th': [3, 5, 7, 9],
          'dominant-ninth': [4, 7, 9, 14], 'nan': [], '[]': [],}

DURATION_SCALE = 0.1
def play_song(file_pd):
  song_song = music_pb2.NoteSequence()
  current_measure = 1
  current_chord_duration = 0
  current_time = 0
  for i in range(len(file_pd["standardized_note"])):
    if file_pd["standardized_note"][i] == 13:
      continue
    # add chord
    if file_pd["measure"][i] > current_measure:
      current_measure += 1
      chord_duration = current_chord_duration
      current_chord_duration = 0
      chord_start_pitch = file_pd["standardized_chord"][i-1] + 12*4
      chord_pitches = [chord_start_pitch]
      if file_pd["chord_type"][i-1] in CHORDS_KEY.keys():
        for j in CHORDS_KEY[file_pd["chord_type"][i-1]]:
          chord_pitches.append(chord_start_pitch + j)
      else:
        print("chord not registered yet")
        print(file_pd["chord_type"][i-1])
      for pitch1 in chord_pitches:
        song_song.notes.add(pitch=pitch1, start_time= current_time - chord_duration, end_time = current_time - 0.001, velocity=60)
      
    # add note
    pitch = file_pd["standardized_note"][i] + 12*(file_pd["note_octave"][i] + 1)
    note_duration = file_pd["note_duration"][i] * DURATION_SCALE
    current_time += note_duration
    current_chord_duration += note_duration
    if file_pd["standardized_note"][i] != -1:
      song_song.notes.add(pitch=pitch, start_time= current_time - note_duration, end_time = current_time, velocity=60, instrument = 2, program = 5)
      pass
  
  song_song.total_time = current_time
  song_song.tempos.add(qpm=60);

  note_seq.plot_sequence(song_song)
  # This is a colab utility method that plays a NoteSequence.
  note_seq.play_sequence(song_song,synth=note_seq.fluidsynth)

!pip install pyfluidsynth

play_song(predict_pd.head(100))